/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package MIFilters.bag;

import MIFilters.instance.AbstractInstanceNoiseFilter;
import weka.core.Instances;
import SIFilters.KeelNoiseFilter;
import Utils.NoiseFilter;
import java.lang.reflect.Constructor;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Abstract class for noise filter algorithms used in multi-instance (MI) data 
 * at the bag level. 
 * 
 * This class of filters maps each bag into a single-instance representation, 
 * applies a single-instance noise filter and fixes bag labels according to noise 
 * instances detected by the filter. 
 * 
 * The method mapsToSingleInstance() is abstract and has to be implemented by 
 * descendent classes. It specifies the mapping method of the multiple 
 * instance input data into a single instance representation.
 * 
 * @author Danel
 */
public abstract class AbstractBagNoiseFilter implements NoiseFilter {
  
  /**
   * Multi-instance data set where the filter is applied. It is the original 
   * data set, i.e., before the application of the filter.
   */
  private final Instances miDataset;

  /**
   * Multi-instance data set generated by the filter once it has been applied 
   * and labels from noisy bags have been fixed.
   */  
  private Instances newMIDataset;
  
  /**
   * Class of the single-instance noise filter to be used. 
   */
  protected Class<? extends KeelNoiseFilter> siFilterClass;
  
  /**
   * Array of decisions of the noise filter over bags of the data set. The 
   * array is sorted so that decisions[0] corresponds to the first bag, 
   * decisions[1] corresponds to the second bag, and so on. A value of 'True' 
   * means that the corresponding bag has been identified as noisy by the filter. 
   */
  private boolean[] decisions;

  /**
   * Number of bags that have been identified as noisy by the filter.
   */
  private int numFiltered;
  
  /**
   * Creates and runs the filter.
   * 
   * @param dataset set of bags where the filter will work out.
   * @param siFilterClass class of single-instance noise filter to be used.
   */
  public AbstractBagNoiseFilter(Instances dataset, Class<? extends KeelNoiseFilter> siFilterClass) {
    miDataset = new Instances(dataset);
    this.siFilterClass = siFilterClass;
  }
  
  /**
   * Applies the filtering algorithm. 
   * 
   * This method has to be overridden in specialized classes. Post processing 
   * is called after applied. The last line of the overriding method should call 
   * the inherited super.apply() to ensure proper post processing. 
   * @throws java.lang.Exception
   */
  public void apply() throws Exception {
    Instances siRepresentation = mapsToSingleInstance(miDataset);
    KeelNoiseFilter filter = getSingleInstanceFilter(siRepresentation);
    decisions = filter.decisions();
    numFiltered = filter.numNoisyExamples();
    newMIDataset = getFixedDataset();
  }
  
  protected abstract Instances mapsToSingleInstance(Instances miData) throws Exception; 
  
  /**
   * Creates and applies a single-instance noise filter to the set of instances 
   * specified. The class of the filter is supplied in the constructor.
   * 
   * @param singleInstanceData set of instances. 
   * 
   * @return a single-instance noise filter.
   */
  protected KeelNoiseFilter getSingleInstanceFilter(Instances singleInstanceData) {
    return getSingleInstanceFilter(siFilterClass, singleInstanceData);
  }
  
  /**
   * Creates and applies a given single-instance noise filter to the set of instances 
   * specified. The class of the filter is supplied as a parameter.
   * 
   * @param siFilterClass class of the filter to be applied.
   * @param singleInstanceData set of instances. 
   * 
   * @return a single-instance noise filter.
   */
  protected KeelNoiseFilter getSingleInstanceFilter(Class<? extends KeelNoiseFilter> siFilterClass, 
          Instances singleInstanceData) {
    KeelNoiseFilter filter = null;
    try {
      Constructor<? extends KeelNoiseFilter> cons;
      cons = siFilterClass.getConstructor(Instances.class);
      filter = cons.newInstance(singleInstanceData);
    } catch (Exception ex) {
      Logger.getLogger(AbstractInstanceNoiseFilter.class.getName()).log(Level.SEVERE, null, ex);
    } 
    return filter;
  }
  
  /**
   * Gets the fixed data set. 
   * @return the dataset after labels of noisy bags has been fixed.
   */
  private Instances getFixedDataset() {
    Instances fixedDataset = new Instances(miDataset);
    for (int i = 0; i < fixedDataset.numInstances(); i++) {
      if (decisions[i]) {
        double val = fixedDataset.get(i).value(2);
        fixedDataset.get(i).setValue(2, 1 - val);
      }
    }
    return fixedDataset;  
  }

  /**
   * Gets the target data set. It is a copy of the data set provided in the 
   * constructor of the filter, i.e., the data set to be filtered. 
   * 
   * @return a reference to the data set subject to filter. 
   */
  protected Instances getMIDataset() {
    return miDataset;  
  }
  
  /**
   * Gets the class of single-instance filter that have been used.
   * 
   * @return class of single-instance filter.
   */  
  public Class<? extends KeelNoiseFilter> getSingleInstanceFilterClass() {
    return siFilterClass;
  }
  
  /**
   * Gets the data set obtained after filtering. 
   * 
   * @return the filtered data set.
   */
  public Instances fixedDataset() {
    return newMIDataset;
  }

  /**
   * Gets the decision of the filter for a specific bag.
   * 
   * @param index the index of the bag. 
   * 
   * @return true if the bag is identified as noisy and false otherwise.
   */
  @Override
  public boolean decision(int index) {
    return decisions[index];
  }
  
  /**
   * Gets the decisions for all the objects of the datasets.
   * 
   * @return a boolean array with all the decisions.
   */
  public boolean[] decisions() {
    return java.util.Arrays.copyOf(decisions, decisions.length);
  }

  /**
   * Gets the number of bags in the original data set to which the filter 
   * has been applied.
   * 
   * @return the number of bags to which the filter has been applied.
   */
  @Override
  public int numObjects() {
    return decisions.length;
  }

  /**
   * Gets the number of bags identified as noisy by the filter.
   * 
   * @return the number of noisy bags.
   */
  @Override
  public int numFiltered() {
    return numFiltered;
  }
          
}
