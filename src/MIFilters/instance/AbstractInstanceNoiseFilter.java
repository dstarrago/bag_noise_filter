/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package MIFilters.instance;

import weka.core.Instances;
import weka.filters.Filter;
import weka.filters.unsupervised.attribute.MultiInstanceToPropositional;
import weka.filters.unsupervised.attribute.Remove;
import SIFilters.KeelNoiseFilter;
import Utils.NoiseFilter;
import Utils.StablePropositionalToMultiInstance;
import java.lang.reflect.Constructor;
import java.util.Arrays;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Abstract class for noise filter algorithms used in multi-instance (MI) data 
 * at the instance level. 
 * 
 * This class of filters transforms the MI data in a single-instance 
 * representation, applies a single-instance noise filter and transforms back the
 * filtered data to the MI representation.
 * 
 * The method apply() has to be overridden by descendent classes. The last line 
 * of the overriding method should call the inherited super.apply() to ensure 
 * proper post processing. 
 * 
 * The followings methods should be invoked by descendent classes:
 * - setDecisions, to inform the decision of the filter on each instance (is/isn't noisy)
 * - setNewMIDataset, to inform the composition of the filtered data set.
 * - setNumFiltered, to inform the number of noisy instance detected by the filter.
 * 
 * @author Danel
 */
public abstract class AbstractInstanceNoiseFilter implements NoiseFilter {
  
  /**
   * Multi-instance data set where the filter is applied. It is the original 
   * data set, i.e., before the application of the filter.
   */
  private final Instances miDataset;

  /**
   * Multi-instance data set generated by the filter once it has been applied 
   * and the noisy instances have been removed from the original data set.
   */  
  private Instances newMIDataset;
  
  /**
   * Class of the single-instance noise filter to be used. 
   * 
   */
  protected Class<? extends KeelNoiseFilter> siFilterClass;
  
  /**
   * Array of decisions of the noise filter over instances of the data set. The 
   * array is sorted so that decisions[0] corresponds to the first instance in 
   * the first bag, decisions[1] corresponds to the second instance in the first
   * bag, and so on. A value of 'True' means that the corresponding instance has 
   * been identified as noisy by the filter. 
   */
  private boolean[] decisions;

  /**
   * Number of instances that have been identified as noisy by the filter.
   */
  private int numFiltered;
  
  /**
   * Array of resulting bag indexes after filtering noisy instance. 
   * 
   * Bags are referred by its sequential index number. However, if all instance 
   * in a bag are removed by the filter, indexes of subsequent bags are 
   * decremented. In this case some bags will have different indexes than that 
   * they originally have. This array is used to store bag index after filtering. 
   * 
   */
  private int[] newBagIndex;
  
  /**
   * Utility constant used in the array newBagIndex to represent the index of a
   * bag that has been removed by the filter because all their instances were 
   * identified as noise.
   */
  private final int nonExistentBag = -1;
  
  /**
   * Creates and runs the filter.
   * 
   * @param dataset set of bags where the filter will work out.
   * @param siFilterClass class of single-instance noise filter to be used.
   */
  public AbstractInstanceNoiseFilter(Instances dataset, Class<? extends KeelNoiseFilter> siFilterClass) {
    miDataset = new Instances(dataset);
    this.siFilterClass = siFilterClass;
  }
  
  /**
   * Creates and applies a single-instance noise filter to the set of instances 
   * specified. The class of the filter is supplied in the constructor.
   * 
   * @param singleInstanceData set of instances. 
   * 
   * @return a single-instance noise filter.
   */
  protected KeelNoiseFilter getSingleInstanceFilter(Instances singleInstanceData) {
    return getSingleInstanceFilter(siFilterClass, singleInstanceData);
  }
  
  /**
   * Creates and applies a given single-instance noise filter to the set of instances 
   * specified. The class of the filter is supplied as a parameter.
   * 
   * @param siFilterClass class of the filter to be applied.
   * @param singleInstanceData set of instances. 
   * 
   * @return a single-instance noise filter.
   */
  protected KeelNoiseFilter getSingleInstanceFilter(Class<? extends KeelNoiseFilter> siFilterClass, 
          Instances singleInstanceData) {
    KeelNoiseFilter filter = null;
    try {
      Constructor<? extends KeelNoiseFilter> cons;
      cons = siFilterClass.getConstructor(Instances.class);
      filter = cons.newInstance(singleInstanceData);
    } catch (Exception ex) {
      Logger.getLogger(AbstractInstanceNoiseFilter.class.getName()).log(Level.SEVERE, null, ex);
    } 
    return filter;
  }
  
  /**
   * Applies the filtering algorithm. 
   * 
   * This method has to be overridden in specialized classes. Post processing 
   * is called after applied. The last line of the overriding method should call 
   * the inherited super.apply() to ensure proper post processing. 
   */
  public void apply() {
    afterApplied();
  }
  
  /**
   * This method is called after filtering and it allows for post processing.
   */
  protected void afterApplied() {
    computeNewBagIndex();
  }
  
  /**
   * Gets the target data set. It is a copy of the data set provided in the 
   * constructor of the filter, i.e., the data set to be filtered. 
   * 
   * @return a reference to the data set subject to filter. 
   */
  protected Instances getMIDataset() {
    return miDataset;  
  }

  /**
   * Sets the data set obtained after filtering. 
   * 
   * This method should be used by any specialized class to set the resulting 
   * data set after the filtering process is finished.
   * 
   * @param newMIDataset the data set.
   */  
  protected void setNewMIDataset(Instances newMIDataset) {
    this.newMIDataset = newMIDataset;
  }
  
  /**
   * Gets the data set obtained after filtering. In this data set, instances 
   * are stored in same sequential order as the original data set but instance 
   * found noisy have been removed.
   * 
   * @return the new data set.
   */
  protected Instances getNewMIDataset() {
    return newMIDataset;
  }
  
  /**
   * Sets the decisions of the filter. 
   * 
   * This method should be used by any specialized class to set its decisions
   * after the filtering process is finished.
   * 
   * @param decisions array of boolean decisions.
   */
  protected void setDecisions(boolean[] decisions) {
    this.decisions = decisions;
  }

  /**  
   * Sets the number of instances identified as noise by the filter algorithm.
   * 
   * This method should be used by any specialized class after the filtering 
   * process is finished.
   * 
   * @param numFiltered number of noisy instances.
   */
  protected void setNumFiltered(int numFiltered) {
    this.numFiltered = numFiltered;
  }

  /**
   * Gets the class of single-instance filter that have been used.
   * 
   * @return class of single-instance filter.
   */  
  public Class<? extends KeelNoiseFilter> getSingleInstanceFilterClass() {
    return siFilterClass;
  }
  
  /**
   * Gets the data set obtained after filtering. Similar to getNewMIDataset().
   * 
   * @return the new data set.
   */
  public Instances safeExamples() {
    return newMIDataset;
  }

  /**
   * Gets the decision of the filter for a specific instance.
   * 
   * @param index the index of the instance. This index is a zero-based 
   * counting of instances of the original data set (i.e., before filtering)
   * once they are arranged so that the first instance in the first bag has 
   * index 0, the second instance in the first bag has index 1, and so on.
   * 
   * @return true if the instance is identified as noisy and false otherwise.
   */
  @Override
  public boolean decision(int index) {
    return decisions[index];
  }
  
  /**
   * Gets the decisions for all the objects of the datasets.
   * 
   * @return a boolean array with all the decisions.
   */
  public boolean[] decisions() {
    return java.util.Arrays.copyOf(decisions, decisions.length);
  }

  /**
   * Gets the number of instances in the original data set (i.e., before 
   * filtering). Here the word instances refers to objects inside bags.
   * 
   * @return the number of instances.
   */
  @Override
  public int numObjects() {
    return decisions.length;
  }

  /**
   * Gets the number of save instances (i.e., not noisy) in a given bag.
   * 
   * @param bagIndex index identifying the bag in the original data set.
   * 
   * @return the number of instance in the bag that are considered clean 
   * by the filter. 
   */
  public int numSafeInstancesInBag(int bagIndex) {
    if (newBagIndex[bagIndex] == nonExistentBag) {
      return 0;
    } else {
      Instances newBag = newMIDataset.get(newBagIndex[bagIndex]).dataset();
      return newBag.numInstances();
    }
  }
  
  /**
   * Gets the number of noisy instances in a given bag.
   * 
   * @param bagIndex index identifying the bag in the original data set.
   * 
   * @return the number of instance in the bag that are considered noisy 
   * by the filter. 
   */
  public int numNoisyInstancesInBag(int bagIndex) {
    Instances bag = miDataset.get(bagIndex).dataset();
    if (newBagIndex[bagIndex] == nonExistentBag) {
      return bag.numInstances();
    } else {
      Instances newBag = newMIDataset.get(newBagIndex[bagIndex]).dataset();
      return bag.numInstances() - newBag.numInstances();
    }
  }
  
  /**
   * Gets the number of instances identified as noisy by the filter.
   * 
   * @return the number of instances.
   */
  @Override
  public int numFiltered() {
    return numFiltered;
  }
          
  /**
   * Recomputes bag indexes and put the information on the array newBagIndex.
   */
  private void computeNewBagIndex() {
    newBagIndex = new int[miDataset.numInstances()];
    Arrays.fill(newBagIndex, nonExistentBag);
    String newBagID;
    int countNewBags = 0;
    if (newMIDataset.numInstances() > 0) {
      newBagID = newMIDataset.get(countNewBags).stringValue(0);
    } else {
      return;
    }
    for (int i = 0; i < miDataset.numInstances(); i++) {
      String bagID = miDataset.get(i).stringValue(0);
      if (bagID.equals(newBagID)) {
        newBagIndex[i] = countNewBags++;
        if (newMIDataset.numInstances() > countNewBags) {
          newBagID = newMIDataset.get(countNewBags).stringValue(0);
        } else {
          return;
        }
      }
    }
  }
  
  /**
   * Maps a multi-instance data set into a single-instance representation 
   * assigning to each instance the class label of its bag. 
   * 
   * @param dataset multi-instance data set to be mapped.
   * @return single-instance data set.
   * 
   * @throws Exception if conversion fails.
   */
  protected Instances toSimpleInstance(Instances dataset) throws Exception {
    MultiInstanceToPropositional mil2proFilter = new MultiInstanceToPropositional();
    mil2proFilter.setOptions(new String[] {"-A","1"});
    mil2proFilter.setInputFormat(dataset);
    Instances siData = Filter.useFilter(dataset, mil2proFilter);
    return siData; 
  }

  /**
   * Transforms back a single-instance representation of a multi-instance 
   * data set. The transformation keeps the order of instances.
   * 
   * @param dataset data set in single-instance representation.
   * 
   * @return multi-instance data set.
   * 
   * @throws Exception if conversion fails.
   */  
  protected Instances toMultiInstance(Instances dataset) throws Exception {
    Instances miData;
    StablePropositionalToMultiInstance filter = new StablePropositionalToMultiInstance();
    filter.setInputFormat(dataset);
    miData = Filter.useFilter(dataset, filter);
    return miData; 
  }

  /**
   * Removes the ID attribute in a single-instance mapping of a multi-instance
   * data set.
   * 
   * @param dataset transformed (multi-instance to single-instance) data set.
   * @return ID-free single-instance data set representation.
   * 
   * @throws Exception if the action fails.
   */  
  protected Instances removeID(Instances dataset) throws Exception {
    Instances noIDData;
    Remove filter = new Remove();
    filter.setOptions(new String[] {"-R","first"});
    filter.setInputFormat(dataset);
    noIDData = Filter.useFilter(dataset, filter);
    return noIDData; 
  }
  
}
